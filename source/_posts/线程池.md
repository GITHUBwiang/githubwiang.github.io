---
title: 线程池
date: 2020-11-29 17:10:44
categories: learn
tags: java
---

# 线程池

<img src="https://cdn.jsdelivr.net/gh/xianglin2020/gallery@master/202011/195501.png" alt="Executor" style="zoom:50%;" />

## 创建和停止线程池

### 线程池的构造器的参数

| 参数名            | 类型                       | 含义                            |
| ----------------- | -------------------------- | ------------------------------- |
| `corePoolSize`    | `int`                      | 核心线程数                      |
| `maximumPoolSize` | `int`                      | 最大线程数                      |
| `keepAliveTime`   | `long`                     | 保持存活时间                    |
| `workQueue`       | `BlockingQueue`            | 任务存储队列                    |
| `threadFactory`   | `ThreadFactory`            | 使用 threadFactory 创建新的线程 |
| `handler`         | `RejectedExecutionHandler` | 拒绝策略                        |

* `corePoolSize`：指的是核心线程数。

* `maxPoolSize`：指的是最大线程数。

	1. 如果线程数小于`corePoolSize`，创建一个新的线程来运行新任务；
	2. 如果线程数等于或大于`corePoolSize`但小于`maximumPoolSize`，则将任务添加到任务队列中；
	3. 如果队列已满，且线程数小于`maximumPoolSize`，则创建新线程；
	4. 如果队列已满，且线程数达到`maximumPoolSize`，则调用`handler`执行拒绝策略。
	
	<img src="https://cdn.jsdelivr.net/gh/xianglin2020/gallery@master/202011/174715.jpg" alt="线程池创建线程步骤" style="zoom:50%;" />
	
* `keepAliveTime`：如果线程池当前的线程数多于`corePoolSize`，那么多余的线程闲置超过指定时间会被终止。

* `threadFactory`：创建线程的工厂。

  <img src="https://cdn.jsdelivr.net/gh/xianglin2020/gallery@master/202011/175254.png" alt="DefaultThreadFactory" style="zoom:50%;" />

  默认线程池创建的线程的属性为：

  1. 属于同一个`ThreadGroup`
  2. 线程池和线程的名称按序号递增
  3. 不是 daemon 线程
  4. 线程的优先级为`NORM_PRIORITY`

  ```java
  private final String namePrefix = "pool-" +
                            poolNumber.getAndIncrement() +
                           "-thread-";
  
  
  public Thread newThread(Runnable r) {
    Thread t = new Thread(group, r,
                          namePrefix + threadNumber.getAndIncrement(),
                          0);
    if (t.isDaemon())
      t.setDaemon(false);
    if (t.getPriority() != Thread.NORM_PRIORITY)
      t.setPriority(Thread.NORM_PRIORITY);
    return t;
  }
  ```

* `workQueue`：任务队列

  1. 直接交接：`SynchronousQueue`
  2. 无界队列：`LinkedBlockingQueue`
  3. 有界队列：`ArrayBlockingQueue`

### Executors创建线程池

| 方法名                    | 功能|缺点|
| ------------------------- | -------------------------------------------------- | -------------------------------------------------- |
| `newFixedThreadPool`      | 创建固定大小的线程池                               |容易造成大量内存占用，导致 OOM|
| `newSingleThreadExecutor` | 创建只有一个线程的线程池                           |当请求堆积的时候，占用大量内存|
| `newCachedThreadPool`     | 创建一个不设线程上限的线程池，任何任务都将立即执行 |创建数量非常多的线程，导致 OOM|

1. `newFixedThreadPool`

   ```java
   public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory){
     return new ThreadPoolExecutor(nThreads, nThreads,
                                   0L, TimeUnit.MILLISECONDS,
                                   new LinkedBlockingQueue<Runnable>(),
                                   threadFactory);
   }
   ```

2. `newSingleThreadExecutor`

   ```java
   public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
     return new FinalizableDelegatedExecutorService
       (new ThreadPoolExecutor(1, 1,
                               0L, TimeUnit.MILLISECONDS,
                               new LinkedBlockingQueue<Runnable>(),
                               threadFactory));
   }
   ```

3. `newCachedThreadPool`

   ```java
   public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                   60L, TimeUnit.SECONDS,
                                   new SynchronousQueue<Runnable>(),
                                   threadFactory);
   }
   ```

   

### 线程池的线程数量如何设定

* CPU 密集型（加密、计算 hash）：最佳线程数为CPU 核心数的 1-2 倍左右；
* 耗时 IO 型（读写数据库、文件、网络）：最大线程数一般会大于 CPU 核心数很多倍。
* 线程数 = CPU 核心数 * (1 + 平均等待时间 / 平均工作时间)

### 线程池状态

| 状态         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| `RUNNING`    | 接收新任务并处理排队任务                                     |
| `SHUTWODN`   | 不接受新任务，但处理排队任务                                 |
| `STOP`       | 不接受新任务，不处理排队任务，并中断正在进行的任务           |
| `TIDYING`    | 所有任务都已经终止，workerCount 为零，并调用`terminated`钩子方法 |
| `TERMINATED` | `terminated()`方法调用完成                                   |



### 停止线程池的方法

* `shutdown`
  1. 将线程池的状态置为`SHUTDOWN`
  2. 调用此方法后，不允许继续提交任务，即调用指定的拒绝策略拒绝任务
  3. 所有在调用此方法前提交的任务都会被执行
  4. 所有任务被执行完毕，`ExecutorService`才会真正关闭
* `shutdownNow`
  1. 将线程池的状态置为`STOP`
  2. 使用中断操作尝试停止运行中的任务
  3. 返回未尚未执行的任务

* `isShutdown`：线程池是否关闭
* `isTerminated`：判断线程池关闭后所有的任务是否都执行完了
* `awaitTermination`：阻塞，直到出现以下情况
  1. `shutdown`调用后所有任务执行完成
  2. 超时返回
  3. 当前线程中断

### 线程池的拒绝策略

线程池已经关闭或者线程池线程数达到最大值且队列已满时需要执行拒绝策略

* `AbortPolicy`：抛出`RejectedExecutionException`

  ```java
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    throw new RejectedExecutionException("Task " + r.toString() +
                                         " rejected from " +
                                         e.toString());
  }
  ```

  

* `DiscardPolicy`：什么也不做，直接忽略

  ```java
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
  }
  ```

  

* `DiscardOldestPolicy`：丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置

  ```java
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
      e.getQueue().poll();
      e.execute(r);
    }
  }
  ```

  

* `CallerRunsPolicy`：直接由提交任务者执行这个任务

  ```java
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
      r.run();
    }
  }
  ```

### 线程池钩子`beforeExecute`

实现一个可以暂停的线程池

```java
public class PauseableThreadPool extends ThreadPoolExecutor {
    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    private boolean isPaused;
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();


    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        lock.lock();
        try {
            while (isPaused) {
                condition.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }


    private void pause() {
        lock.lock();
        try {
            isPaused = true;
        } finally {
            lock.unlock();
        }
    }

    private void resume() {
        lock.lock();
        try {
            isPaused = false;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
    
}
```

### 线程池组成部分

* 线程池管理器
* 工作线程：`Worker`
* 任务队列
* 任务接口



