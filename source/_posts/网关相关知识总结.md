---
title: 网络相关知识总结
date: 2020-12-20 11:01:32
categories: interview
tags: 网络
---

## 网络基础知识

国际标准化组织 ISO 提出的开放系统互联基本参考模型（Open Systems Interconnection Reference Model），简称为 OSI ，是一个概念模型。TCP/IP 是一个四层的体系结构，它包含应用层、 运输层、网际层和网络接口层。在阐述计算机网络原理时，通常综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构。

![image-20201223085010412](https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201223085010412.png)

### 应用层（application layer）

应用层的作用是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（主机中正在运行的程序）间通信和交互的规则。如域名系统 DNS、支持万维网的 HTTP 协议和支持电子邮件的 SMTP 协议。应用层交互的数据单元称为报文（message）。

### 运输层（transport layer）

运输层的任务就是负责向两台主机中进程间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。运输层具有复用和分用两个功能。复用是指多个应用层进程可以同时使用下面运输层的服务，分用是指运输层把收到的信息分别交付给上面应用层中的相应进程。运输层主要使用 TCP 和 UDP 两种协议。

* 传输控制协议 TCP（Transmission Control Protocol）：提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段。
* 用户数据报协议 UDP（User Datagram Protocol）：提供无连接的、尽最大努力交付（不保证数据传输可靠性）的数据传输服务，其数据传输的单位是用户数据报。

### 网络层（network layer）

网络层主要有两个任务：

1. 为分组交换组网上的不同主机提供通信服务，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。
2. 选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。

### 数据链路层（data link layer）

两台主机之间的数据传输，总是在一段一段的数据链路上传送的，这就需要专门的链路层协议。在两个相邻节点传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传递帧。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。

### 物理层（physical layer）

在物理层上传输的单位是比特。物理层需要考虑多大的电压表示 “1” 或 “0” ，以及接收方如何识别发送方所发送的比特。物理层还要确定连接电缆的插头应该有多少根引脚以及各引脚应如何连接。

## TCP/IP 协议族

TCP/IP 的体系结构只有四层。

![image-20201224220142706](https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224220142706.png)

可以分层画出具体的协议来表示 TCP/IP 协议族，它的特点是上下两头大而中间小：应用层和网络接口层都有多种协议，而中间的 IP 层很小，上层的各种协议都向下汇聚到一个 IP 协议中。这表明：TCP/IP 协议可以为各式各样的应用提供服务，同时 TCP/IP 协议也允许 IP 协议在各式各样的网络构成的互联网上运行。

![image-20201224220539509](https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224220539509.png)

## TCP 基础知识

### TCP 的主要特点

* TCP 是面向连接的运输层协议。应用程序在使用 TCP 协议之前，必须建立 TCP 连接。在传送完数据之后，必须释放已经建立的 TCP 连接。
* 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的。
* TCP 连接提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。
* TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。
* 面向字节流。TCP 中的 流（stream）指的是流入到进程或从进程流出的字节序列。

### TCP 报文段的首部格式

TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项。因此 TCP 首部的最小长度是 20 字节。

![image-20201223220408024](https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201223220408024.png)

* 源端口和目的端口：各占 2 个字节，分别写入源端口号和目的端口号。
* 序号：占 4 个字节。序号范围是 [0, 2^32 -1] ，且使用 mod 2^32 运算。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在建立连接时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节序号。
* 确认号：占 4 个字节，是期望收到对方下一个报文段的第一个数据字节的编号。例如，B 正确收到了 A 发送的一个报文段，其序号字段值是 501，而数据长度是 200 字节，这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发给 A 的确认报文段中把确认号设置为 701 。
* 数据偏移：占 4 位，指出 TCP 报文段的首部长度。“数据偏移”的单位是 32 位字（4 字节），4 位二进制最大表示十进制 15，因此“数据偏移”字段的最大值是 60 字节，这同时是 TCP 首部的最大长度。
* 保留：占 6 位，目前应置为 0 。
* 六个标志位：
  * 紧急 URG ：当 URG = 1 时，表明紧急字段有效。发送应用进程告诉系统 TCP 有紧急数据要传送，于是 TCP 就把紧急数据插入本报文段数据的最前面，而后面的数据仍是普通数据。这时需要与首部中紧急指针字段配合使用。
  * 确认 ACK ： 仅当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。TCP 规定，在建立连接后所有传送的报文段都必须把 ACK 置 1 。
  * 推送 PSH ：发送方 TCP 把 PSH 置 1，并理立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用程序。
  * 复位 RST ：当 RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接。
  * 同步 SYN ：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则在相应的报文段中使用 SYN = 1 和 ACK = 1 。因此，SYN 置为 1 就表示这是一个请求或接收建立连接报文。
  * 终止 FIN ：用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
* 窗口：占 2 个字节。窗口值是 [0, 2^16 -1] 之间的整数。窗口指发送本报文段的一端的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。
* 校验和：占 2 个字节。校验和字段校验的范围包括首部和数据这两部分。同样需要伪首部。
* 紧急指针：占 2 个字节。仅在 URG = 1 时才有意义。即使窗口为零时也可以发送紧急数据。
* 选项：长度可变，最长可达 40 字节。

### TCP 可靠传输的工作原理

TCP 所发送的报文段是交给 IP 层传送的，但是 IP 层只能提供最大努力服务，也就是说，TCP 下面的网络所提供的是不可靠的传输。TCP 必须采用适当的措施才能使得两个运输层之间的通信变得可靠。

#### 停止等待协议

“停止等待协议”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。

1. 无差错情况

   <img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224221251156.png" alt="image-20201224221251156" style="zoom:50%;" />

   A 发送分组 M1，发送完后暂停发送，等待 B 的确认。B 收到了 M1 就向 A 发送确认。A 在收到对 M1 的确认后，在发送下一个分组 M2 。同样，在收到 B 对 M2 的确认后，再发送 M3 。

2. 出现差错

   <img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224221531171.png" alt="image-20201224221531171" style="zoom:50%;" />

   分组在传输过程中出现差错，B 在接收 M1 时检测到差错，就丢弃 M1，其它什么也不做（也不通知 A 收到有差错的分组）。也可能是 M1 在传输过程中丢失了，这时 B 什么都不知道。可靠传输协议中超时重传的设计是：A 只要超过一段时间仍然没有收到确认，就会认为刚才发送的分组丢失了，因而重传前面发送的分组。

3. 确认丢失和确认迟到

   <img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224222109531.png" alt="image-20201224222109531" style="zoom:67%;" />

   A 发送分组后等待超时就会重传分组，B 在接受到重复分组时：丢弃重复的分组，对分组进行确认。A 在收到重复的确认时：收下后就丢弃。

#### 连续 ARQ 协议

<img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224222656888.png" alt="image-20201224222656888" style="zoom:67%;" />

发送方维持一个发送窗口，它的意义是：位于发送窗口的 5 个分组都可以连续发送出去，而不需要等待对方的确认。可以提高信道利用率。发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。

接收方一般都是采用累积确认的方式。不必对接收到的分组逐个发送确认，而是在收到几个分组后，对按顺序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确接收了。

### TCP 可靠传输的实现

* 以字节为单位的滑动窗口

* 超时重传时间的选择

* 选择确认 SACK

## TCP 滑动窗口协议

TCP 的滑动窗口是以字节为单位的。

### 发送方的滑动窗口

1. 构建发送窗口

   现假定 A 收到了 B 发来的确认报文段，其窗口值是 20 字节，确认号是 31 。根据这两个数据，A 可以构造出自己的发送窗口。

   ![image-20201224223718570](https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224223718570.png)

   发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。

   发送窗口后沿的后面部分表示已经发送且已收到确认。这些数据不需要再保留。而发送窗口前沿的前面部分表示不允许发送，因为接收方都没有为这部分数据保留临时存放的缓冲区。

2. 部分发送但未收到确认

   假定 A 发送了序号为 31 ~ 41 的数据。这时，发送窗口位置未改变，但发送窗口内靠后面有 11 个字节表示已发送但未收到确认。发送窗口内靠前面的 9 个字节是允许发送但尚未发送的。

   <img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224224655408.png" alt="image-20201224224655408" style="zoom:67%;" />

3. 收到确认后发送窗口向前滑动

   <img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224231519787.png" alt="image-20201224231519787" style="zoom:67%;" />

   发送方 A 在收到 B 的确认号 33 后，就可以把发送窗口向前滑动 3 个序号，此时可发送的序号范围是 42 ~ 53 。

### 接收方的滑动窗口

接收窗口的状态有三种：已经接收且已回复、允许接收但未收到、不允许接收。

1.  接收方接收窗口的初始状态

   ![image-20201224231946417](https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224231946417.png)

   B 的接收窗口大小是 20 ，在接收窗口外面，到 30 号为止的数据是已经发送过确认且上交给主机的。接收窗口内的序号 31 ~ 50 是允许接收的。

   B 只能对按顺序收到的数据中的最高序号给予确认，因此 B 即使收到了序号为 32、33 的数据，因为序号为 31 的数据未收到，此时 B 对 A 的确认报文中的确认号仍然是 31 。

2. B 接收到序号连续的数据

   <img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224233004635.png" alt="image-20201224233004635" style="zoom:67%;" />

   当 B 接收到序号为 31 的数据，并把序号为 31 ~ 33 的数据交付主机，然后 B 删除这些数据。接着把接收窗口向前移动 3 个序号，同时给 A 发送确认，其中窗口值仍是 20 ，但确认号是 34 。

### 窗口与缓存的关系

<img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201224233353821.png" alt="image-20201224233353821" style="zoom:67%;" />

## TCP 的运输连接管理

### TCP 的三次握手

### TCP 的四次挥手

## UDP 基础知识

### UDP 的主要特点

* UDP 是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
* UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。
* UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分。在添加首部后就向下交付给 IP 层。
* UDP 没有拥塞控制，网络出现拥塞不会使源主机的发送速率降低。适用于 IP 电话、实时视频会议、视频直播等场景。
* UDP 支持一对一、一对多、多对多的交互通信。
* UDP 的首部开销小，只有 8 个字节。

### UDP 的首部格式

用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段占用 8 个字节，由四个字段组成。

![image-20201223214151844](https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/image-20201223214151844.png)

* 源端口：源端口号，在需要对方回信时选用，不需要时可用全 0 。
* 目的端口：目的端口号，在终点交付报文时必须使用。
* 长度：UDP 用户数据报的长度，其值最小是 8 （仅有首部）。
* 校验和：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。

*伪首部用于 UDP 计算校验和，既不向下传送也不向上递交*

## HTTP 协议

### 常见状态码

### GET 请求与 POST 请求的区别

### Cookis 和 Session 的区别

### HTTP 和 HTTPS 协议的区别

#### SSL

## Socket

Socket 是对 TCP/IP 协议的抽象，是操作系统对外开放的接口。

### Socket 通信过程 

<img src="https://raw.githubusercontent.com/xianglin2020/gallery/master/202012/Socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.jpg" alt="Socket通信过程" style="zoom:50%;" />

### Java 使用 Socket 通信

使用 Socket 编写网络应用程序，分别用 TCP 和 UDP 的方式实现。

* 使用 TCP 实现

  ```java
  /**
   * 使用 Sockets 实现 Tcp服务端
   */
  public class TcpServer {
      public static void main(String[] args) {
          try {
              // 创建一个Sockets服务，并绑定在本机的9509端口上
              ServerSocket serverSocket = new ServerSocket(9509);
              // 循环监听客户端链接
              while (true) {
                  // 有客户端链接才返回
                  Socket socket = serverSocket.accept();
                  // 新建一个服务线程处理任务
                  new TcpService(socket).start();
              }
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  
  
  class TcpService extends Thread {
      private final Socket socket;
  
      TcpService(Socket socket) {
          this.socket = socket;
      }
  
      @Override
      public void run() {
          try {
              // 获取socket对应的输入流和输出流
              InputStream inputStream = this.socket.getInputStream();
              OutputStream outputStream = this.socket.getOutputStream();
              // 读取客户端发送的数据
              byte[] bytes = new byte[1024];
              int read = inputStream.read(bytes);
              String content = new String(bytes, 0, read);
              System.out.println("收到客户端信息：" + content);
              // 返回字符串长度
              outputStream.write(String.valueOf(content.length()).getBytes(StandardCharsets.UTF_8));
              // 关闭连接资源
              outputStream.close();
              inputStream.close();
              this.socket.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  
  /**
   * 使用Sockets 完成Tcp客户端
   */
  public class TcpClient {
      public static void main(String[] args) {
          try {
              // 创建Socket对象，指定ip地址和端口
              Socket socket = new Socket("127.0.0.1", 9509);
              // 使用输出流向服务端发送数据
              OutputStream outputStream = socket.getOutputStream();
              outputStream.write("Hello World!".getBytes(StandardCharsets.UTF_8));
              // 使用输入流接收服务端返回的数据
              InputStream inputStream = socket.getInputStream();
              byte[] bytes = new byte[1024];
              int read = inputStream.read(bytes);
              System.out.println("收到服务端回应：" + new String(bytes, 0, read));
              // 关闭连接资源
              outputStream.close();
              inputStream.close();
              socket.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

* 使用 UDP 实现

  ```java
  /**
   * 使用Socket实现UDP服务端
   */
  public class UdpServer {
      public static void main(String[] args) {
          try {
              // 为本机创建一个DatagramSocket对象，并绑定到9509端口
              DatagramSocket datagramSocket = new DatagramSocket(9509);
              // 创建DatagramPacket对应接收客户端发送的数据
              byte[] bytes = new byte[1024];
              DatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length);
              // 将客户端发送的数据保存到DatagramPacket对象中
              datagramSocket.receive(datagramPacket);
              // 打印内容
              byte[] data = datagramPacket.getData();
              String content = new String(data, 0, datagramPacket.getLength());
              System.out.println("接收客户端请求：" + content);
  
              // 创建DatagramPacket对象，封装需要发送给客户端的内容
              byte[] sendBytes = String.valueOf(content.length()).getBytes(StandardCharsets.UTF_8);
              // 获取客户端的地址和端口
              DatagramPacket datagramPacket1 = new DatagramPacket(sendBytes, sendBytes.length, datagramPacket.getAddress(), datagramPacket.getPort());
              // 将数据发送给客户端
              datagramSocket.send(datagramPacket1);
              datagramSocket.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  
  /**
   * 使用Socket实现UDP客户端
   */
  public class UdpClient {
      public static void main(String[] args) {
          try {
              // 客户端发送给服务端的内容
              byte[] bytes = "Hello World!".getBytes(StandardCharsets.UTF_8);
              // 获取本机对应的InetAddress对象
              InetAddress localHost = InetAddress.getLocalHost();
              // 创建DatagramSocket对象
              DatagramSocket datagramSocket = new DatagramSocket();
              // 将需要发送的内容封装成DatagramPacket对象，并指定服务端的ip和端口
              DatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length, localHost, 9509);
              // 发送数据给服务端
              datagramSocket.send(datagramPacket);
  
              // 接收服务端的返回
              byte[] receive = new byte[1024];
              // 创建DatagramPacket对象存储服务端返回的数据
              DatagramPacket datagramPacket1 = new DatagramPacket(receive, receive.length);
              // 接收数据，并存储到DatagramPacket中
              datagramSocket.receive(datagramPacket1);
              // 打印服务端返回的内容
              System.out.println("服务端返回：" + new String(datagramPacket1.getData(), 0, datagramPacket1.getLength()));
              datagramSocket.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  
